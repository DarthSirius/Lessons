[
    {
        "name":	"Инициализация пароля в исходном коде (C#)",
        "className": "FindNodeByChildPartOfNameAndSubnode",
        "type": "Identifier,VariableDeclarator",
        "tokens": "password,pass,passwd,paswd,pswd,pwd,pword,PASSWORD,PASS,PASSWD,PASWD,PSWD,PWD,PWORD",
        "language":	"C#",
        "active": true,
        "description": "Проверка «Инициализация пароля в исходном коде» выявляет явно инициализированный пароль в исходном коде. Это может привести к компрометации данных приложения.",
        "possibleThreats": "-Утечка конфиденциальной информации;",
        "recommendations": "-Храните не пароли, а значения криптографически стойкой хеш-функции от паролей. Используйте специализированные хеш-функции, предназначенные для этой цели (bcrypt, PBKDF2, scrypt); -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Храните аутентификационную информацию в зашифрованном виде в отдельном конфигурационном файле или в базе данных. Обеспечьте безопасную защиту ключа шифрования. Если использовать шифрование невозможно, максимально ограничьте доступ к хранилищу.",
        "example": "String password;",
        "rule":	{}
    },
    {
        "name":	"Присвоение пароля в исходном коде (C#)",
        "className": "FindNodeByChildPartOfNameAndSubnode",
        "type": "Identifier,AssignmentExpression",
        "tokens": "password,pass,passwd,paswd,pswd,pwd,pword,PASSWORD,PASS,PASSWD,PASWD,PSWD,PWD,PWORD",
        "language": "C#",
        "active": true,
        "description": "Проверка «Присвоение пароля в исходном коде» выявляет явно заданный пароль в исходном коде. Это может привести к компрометации данных приложения.",
        "possibleThreats": "-Утечка конфиденциальной информации;",
        "recommendations": "-Храните не пароли, а значения криптографически стойкой хеш-функции от паролей. Используйте специализированные хеш-функции, предназначенные для этой цели (bcrypt, PBKDF2, scrypt); -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Храните аутентификационную информацию в зашифрованном виде в отдельном конфигурационном файле или в базе данных. Обеспечьте безопасную защиту ключа шифрования. Если использовать шифрование невозможно, максимально ограничьте доступ к хранилищу.",
        "example": "password = \"Pa$$word\";",
        "rule":	{}
    },
    {
        "name": "Инициализация пароля значением null (C#)",
        "className": "FindNodeByChildPartOfNameAndSubnode",
        "type": "Identifier,VariableDeclarator,VariableInitializer,LiteralExpression",
        "tokens": "password,pass,passwd,paswd,pswd,pwd,pword,PASSWORD,PASS,PASSWD,PASWD,PSWD,PWD,PWORD,null",
        "language": "C#",
        "active": true,
        "description": "Проверка «Инициализация пароля значением null» выявляет явно заданный пароль в исходном коде, проинициализированний значением «null». Присваивание значения «null» переменным, отвечающим за пароль, может позволить злоумышленникам обойти проверку пароля или может означать, что ресурсы защищены пустым паролем.",
        "possibleThreats": "-Утечка конфиденциальной информации; -Обход авторизации;",
        "recommendations": "-Используйте ненулевые пароли; -Храните не пароли, а значения криптографически стойкой хеш-функции от паролей. Используйте специализированные хеш-функции, предназначенные для этой цели (bcrypt, PBKDF2, scrypt); -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Храните аутентификационную информацию в зашифрованном виде в отдельном конфигурационном файле или в базе данных. Обеспечьте безопасную защиту ключа шифрования. Если использовать шифрование невозможно, максимально ограничьте доступ к хранилищу.",
        "example": "String password = null;",
        "rule": {}
    },
    {
        "name": "Присвоение паролю значения null (C#)",
        "className": "FindNodeByChildPartOfNameAndSubnode",
        "type": "Identifier,AssignmentExpression,LiteralExpression,Literal",
        "tokens": "password,pass,passwd,paswd,pswd,pwd,pword,PASSWORD,PASS,PASSWD,PASWD,PSWD,PWD,PWORD,null",
        "language": "C#",
        "active": true,
        "description": "Проверка «Присвоение паролю значения null» выявляет явно заданный пароль в исходном коде, которому присвоено значение «null». Присваивание значения «null» переменным, отвечающим за пароль, может позволить злоумышленникам обойти проверку пароля или может означать, что ресурсы защищены пустым паролем.",
        "possibleThreats": "-Утечка конфиденциальной информации; -Обход авторизации;",
        "recommendations": "-Используйте ненулевые пароли; -Храните не пароли, а значения криптографически стойкой хеш-функции от паролей. Используйте специализированные хеш-функции, предназначенные для этой цели (bcrypt, PBKDF2, scrypt); -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Храните аутентификационную информацию в зашифрованном виде в отдельном конфигурационном файле или в базе данных. Обеспечьте безопасную защиту ключа шифрования. Если использовать шифрование невозможно, максимально ограничьте доступ к хранилищу.",
        "example": "password = null;",
        "rule": {}
    },
    {
        "name": "Инициализация пустого пароля (C#)",
        "className": "FindNodeByChildPartOfNameAndSubnode",
        "type": "Identifier,VariableDeclarator,VariableInitializer,LiteralExpression",
        "tokens": "password,pass,passwd,paswd,pswd,pwd,pword,PASSWORD,PASS,PASSWD,PASWD,PSWD,PWD,PWORD,\"\"",
        "language": "C#",
        "active": true,
        "description": "Проверка «Пустой пароль» выявляет явно заданный пароль в исходном коде, инициализированный пустым строковым литералом. Это может привести к компрометации приложения. Информация о том, что определённая учётная запись принимает пустой пароль, как минимум доступна каждому разработчику приложения.",
        "possibleThreats": "-Утечка конфиденциальной информации; -Обход авторизации;",
        "recommendations": "-Не используйте пустые пароли; -Храните не пароли, а значения криптографически стойкой хеш-функции от паролей. Используйте специализированные хеш-функции, предназначенные для этой цели (bcrypt, PBKDF2, scrypt); -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Храните аутентификационную информацию в зашифрованном виде в отдельном конфигурационном файле или в базе данных. Обеспечьте безопасную защиту ключа шифрования. Если использовать шифрование невозможно, максимально ограничьте доступ к хранилищу.",
        "example": "String password = '';",
        "rule": {}
    },
    {
        "name": "Присвоение пустого пароля (C#)",
        "className": "FindNodeByChildPartOfNameAndSubnode",
        "type": "Identifier,AssignmentExpression,LiteralExpression,Literal",
        "tokens": "password,pass,passwd,paswd,pswd,pwd,pword,PASSWORD,PASS,PASSWD,PASWD,PSWD,PWD,PWORD,\"\"",
        "language": "C#",
        "active": true,
        "description": "Проверка «Пустой пароль» выявляет явно заданный пароль в исходном коде, которому присвоен пустой строковый литерал. Это может привести к компрометации приложения. Информация о том, что определённая учётная запись принимает пустой пароль, как минимум доступна каждому разработчику приложения.",
        "possibleThreats": "-Утечка конфиденциальной информации; -Обход авторизации;",
        "recommendations": "-Не используйте пустые пароли; -Храните не пароли, а значения криптографически стойкой хеш-функции от паролей. Используйте специализированные хеш-функции, предназначенные для этой цели (bcrypt, PBKDF2, scrypt); -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Используйте соль, полученную из криптографически стойкого генератора псевдослучайных чисел, для борьбы с атаками, использующими радужные таблицы; -Храните аутентификационную информацию в зашифрованном виде в отдельном конфигурационном файле или в базе данных. Обеспечьте безопасную защиту ключа шифрования. Если использовать шифрование невозможно, максимально ограничьте доступ к хранилищу.",
        "example": "password = '';",
        "rule": {}
    },

    {
        "name": "Небезопасная генерация псевдорандомных чисел (C#)",
        "className": "FindArgumentUsingInFunction",
        "type": "Identifier,CreationClause,ArgumentList,NumericLiteral",
        "tokens": "Random",
        "language": "C#",
        "active": true,
        "description": "Проверка «Небезопасная псевдорандомизация» выявляет случаи передачи константного целочисленного значения в качестве аргумента в функции установки зерна для генератора псевдорандомных чисел. Если в качестве зерна для генератора псевдорандомных чисел установлено константное целочисленное значение, то возвращаемое при генерации значение предсказуемо",
        "possibleThreats": "-Прогнозируемые результаты генерации псевдорандомных чисел; -Нарушение конфиденциальности; -Предсказуемое поведение программы;",
        "recommendations": "Не используйте константные значения при задании зерна для генератора псевдорандомных чисел.",
        "example": "Random rnd = new Random(123);",
        "rule": {}
    },

    {
        "name": "Вызов GC.Collect()",
        "className": "FindCallExpression",
        "type": "NameExpression,CallExpression,Identifier",
        "tokens": "GC,Collect",
        "language": "C#",
        "active": true,
        "description": "Проверка «Вызов GC.Collect()» определяет наличие в коде вызова метода GC.Collect(). Явные запросы на сборку мусора – это маркер, указывающий на вероятные проблемы с производительностью. Практически во всех случаях, вызов GC.Collect() является неправильным действием. На самом деле, вызов GC.Collect() может вызвать проблемы с производительностью, если он вызывается слишком часто.",
        "possibleThreats": "-Ухудшение качества кода; -Снижение производительности; -Неожидаемое поведение программы;",
        "recommendations": "Не вызывать принудительно метод GC.Collect().",
        "example": "GC.Collect();",
        "rule": {}
    },
    {
        "name": "Специальная учётная запись (C#)",
        "className": "FindNodeByChildPartOfNameAndSubnode",
        "type": "Identifier,IfStatement",
        "tokens": "login,LOGIN,user,USER,cookie,COOKIE,admin,ADMIN",
        "language": "C#",
        "active": true,
        "description": "Проверка «Специальная учётная запись (C#)» выявляет наличие данных учетной записи в исходном коде.\n\nПриложение сравнивает значение переменной, хранящей данные аутентификации, с константным значением. Эта специальная учётная запись может являться частью бэкдора.\n\nРазработчик приложения мог использовать специальную учётную запись (возможно, с повышенными привилегиями) при отладке и оставил соответствующие участки кода в финальной версии, сохранив за собой доступ к функциональности приложения. \n\nЗлоумышленник может декомпилировать приложение, извлечь константные строки, задающие параметры специальной учётной записи, и получить доступ к приложению. Константные параметры (логины, пароли, ключи) не должны храниться в исходном коде приложения.",
        "possibleThreats": "-Утечка конфиденциальных данных;",
        "recommendations": "-Удалите константные логины, пароли, ключи и проч. из исходного кода приложения; -Храните данные учётных записей в зашифрованном виде в отдельном файле или в базе данных.",
        "example": "if (login.Equals(\"superAdmin@mail.com\")) {...}",
        "rule": {}
    },
    {
        "name": "Вызов метода Equals() с аргументом null",
        "className": "FindArgumentUsingInFunction",
        "type": "Identifier,CallExpression,ArgumentList,Literal",
        "tokens": "Equals,null",
        "language": "C#",
        "active": true,
        "description": "Проверка «Вызов метода Equals() с аргументом null» определяет наличие в коде вызова метода Equals() с аргументом null. Выражение obj.Equals(null) всегда должно быть ложным, поскольку правило метода Equals() требует, чтобы это сравнение всегда возвращало значение false.",
        "possibleThreats": "-Ухудшение качества кода; -Неожидаемое поведение программы;",
        "recommendations": "Использовать вместо выражения obj.Equals(null) выражение obj == null.",
        "example": "if (conn.Equals(null)) {...}",
        "rule": {}
    }
]